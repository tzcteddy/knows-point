# 基础

## 介绍箭头函数和普通函数的区别
## some、every、find、filter、map、forEach有什么区别

## 介绍defineProperty⽅法，什么时候需要用到
### 介绍
Object.defineProperty  是 JavaScript 中的一个方法，用于在对象上定义一个新属性，或者修改一个已有属性的特性。这个方法提供了对对象属性的更细粒度的控制，允许你设置属性的描述符（descriptor），如可枚举性、可写性和可配置性
```js
Object.defineProperty(obj,prop,descriptor)
```
1. **obj**：操作对象
2. **prop**：操作属性
3. **descriptor**：属性描述
    - **value**：属性的值，默认为  undefined 。 
    - **writable**：一个布尔值，指示属性是否可以被赋值运算符改变。默认为  false 。 
    - **enumerable**：一个布尔值，指示属性是否可以被枚举（例如在  for...in  循环中）。默认为  false 。 
    - **configurable**：一个布尔值，指示属性是否可以被删除或是否可以修改其特性（如  writable  和  enumerable ）。默认为  false 。 
    - **get**：一个 getter 函数，定义属性的访问器（getter）。 
    - **set**：一个 setter 函数，定义属性的设置器（setter）。

 使用场景
- **控制属性特性**：当你需要更精确地控制对象属性的行为时，比如设置属性为不可写、不可枚举或不可配置。 
 
- **定义访问器属性**：当你需要创建具有 getter 和 setter 的属性时，可以使用  Object.defineProperty  来定义这些访问器。 
 
- **数据封装**：在创建类或模块时，可以使用  Object.defineProperty  来封装数据，确保内部状态不会被外部代码直接修改。 
 
- **实现私有属性**：通过将属性设置为不可枚举和不可配置，可以实现类似私有属性的效果。

## for..in 和 object.keys的区别
-  `for..in` 是一种用于遍历对象可枚举属性的循环语句。它会遍历对象及其原型链上的所有可枚举属性。
- `Object.keys()`  是一个静态方法，它返回一个数组，数组中包含对象自身的所有可枚举属性的键（不包括原型链上的属性）。

主要区别 
 
1. **遍历的范围**： 
   -  `for..in` ：遍历对象的所有可枚举属性，包括从原型链继承的属性。 
   -  `Object.keys()` ：只返回对象自身的可枚举属性，不包括原型链上的属性。 
 
2. **返回值**： 
   -  `for..in` ：没有返回值，它是一个循环结构。 
   -  `Object.keys()` ：返回一个数组，包含对象自身的所有可枚举属性的键。 
 
3. **使用场景**： 
   -  `for..in` ：适用于需要遍历对象及其原型链上的所有属性的场景。 
   -  `Object.keys()` ：适用于只需要获取对象自身属性的场景，特别是在需要对属性进行数组操作时。 
 
### 注意事项 
- 在使用  `for..in`  时，通常建议使用  `hasOwnProperty`  方法来检查属性是否为对象自身的属性，以避免遍历到原型链上的属性：
-  `Object.keys()`  只会返回对象自身的属性，因此不需要额外的检查。

## 怎么实现this对象的深拷⻉
- 使用JSON.stringigy()和JSON.parse(),但只适用于对象中没有函数、 undefined 、 Symbol 、 Date 、 RegExp  等特殊类型的情况。
- 使用递归方法
- 在现代浏览器中，可以使用  structuredClone  方法，它可以深拷贝大多数类型的对象，包括  Map 、 Set 、 Date 、 ArrayBuffer  等。
- 使用第三方库

## 网站SEO怎么处理
## 如何判断⼀一个变量是不是数组
## 标签⽣成的Dom结构是⼀一个类数组
## 类数组和数组的区别
## dom的类数组如何转成数组
## 介绍单⻚面应用和多页面应⽤
## 从输⼊入URL到页面加载全过程
## == 和 ===的区别，什么情况下用相等==
## bind、call、apply的区别
## 介绍this各种情况
## 动画的了了解

## ES6新的特性
## ES6中的map和原⽣的对象有什么区别
## ES5和ES6有什么区别

## 介绍暂时性死区
## 介绍纯函数

# 类

## 介绍class和ES5的类以及区别

定义语法
- ES5 使用构造函数和原型链来定义类，语法较为繁琐。
- ES6 使用  class  关键字，语法更加简洁和易读。

构造函数
- 在 ES5 中，构造函数是普通的函数。 
- 在 ES6 中，构造函数是  `constructor`  方法，且每个类只能有一个  `constructor`  方法。

方法定义
- ES5 中的方法是通过原型对象添加的。 
- ES6 中的方法可以直接在类体内定义，不需要使用  prototype 。

继承 
- ES5 中的继承需要手动设置原型链。 
- ES6 中使用  extends  关键字进行继承，语法更加直观。

## 如何区分是ES6 Class和Function Class
函数和class本身是有toString方法的
```js
function isES6Class(klass) {
   return klass.toString().startsWith('class')
}
```

## JS继承⽅方案
- 类式继承
- 构造函数式继承
- 组合式继承
- 原型继承
- 寄生式继承
- 寄生组合式继承
[https://tzcteddy.github.io/knows-point/#/javascript/%E6%B7%B1%E5%85%A5js%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86](https://tzcteddy.github.io/knows-point/#/javascript/%E6%B7%B1%E5%85%A5js%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86)

## 介绍下原型链（解决的是继承问题吗）
原型链（Prototype Chain）是 JavaScript 中实现对象继承的一种机制，它允许对象通过其原型访问其他对象的属性和方法。原型链是 JavaScript 中实现继承的重要概念，但**它不仅仅解决继承问题，还涉及到对象的属性查找和方法共享**。 

## prototype和\_\_proto\_\_ 区别
prototype  
- **定义**： prototype  是一个属性，存在于函数对象上。每当你创建一个对象实例时，这个实例会通过构造函数的  prototype  属性来继承属性和方法。 
- **用途**： prototype  用于定义构造函数的共享属性和方法，这些属性和方法将被所有实例共享。

\_\_proto\_\_  
- **定义**： \_\_proto\_\_   是每个对象的一个内部属性，它指向该对象的原型（即构造函数的  prototype  属性）。 \_\_proto\_\_   不是标准的 ECMAScript 属性，但大多数现代浏览器都支持它。 
 
- **用途**： \_\_proto\_\_   用于访问和修改对象的原型链。通过  \_\_proto\_\_  ，可以查看一个对象的原型以及其原型链上的属性和方法。 

## constructor是什什么
ES6类中的构造函数
1. **创建对象**：构造函数和类都用于创建对象实例。 
2. **使用  new  关键字**：在调用构造函数或类时，通常使用  new  关键字来创建新对象。 
3. **初始化属性**：构造函数和类的构造方法用于初始化对象的属性。 
4. **原型方法**：可以通过原型或类的方法定义对象的行为。

## new是怎么实现的
1. **创建一个新对象**： 
   -  new  操作符首先会创建一个新的空对象（ {} ）。 

2. **设置原型**： 
   - 新创建的对象的原型（ __proto__ ）被设置为构造函数的  prototype  属性。这使得新对象可以访问构造函数原型上定义的方法和属性。 
 
3. **绑定  this **： 
   - 在构造函数内部， this  被绑定到新创建的对象上。这意味着在构造函数中，所有通过  this  访问的属性和方法都会被添加到新对象上。 
 
4. **执行构造函数**： 
   - 调用构造函数并传递任何参数。构造函数中的代码会执行，并对新对象进行初始化。 
 
5. **返回对象**： 
   - 如果构造函数没有显式返回一个对象， new  表达式会自动返回新创建的对象。如果构造函数返回一个对象，则返回该对象。 
```js
function myNew(constructor, ...args) {
    // 创建一个新对象
    const obj = {};
    
    // 将新对象的原型指向构造函数的 prototype
    Object.setPrototypeOf(obj, constructor.prototype);
    
    // 执行构造函数，并将 `this` 绑定到新对象
    const result = constructor.apply(obj, args);
    
    // 如果构造函数返回一个对象，则返回该对象，否则返回新对象
    return (typeof result === 'object' && result !== null) ? result : obj;
}
```

# 事件循环

## 介绍宏任务和微任务
在 JavaScript 中，宏任务（macrotasks）和微任务（microtasks）是两种不同的任务调度机制，主要用于处理异步操作。它们在事件循环（Event Loop）中有着不同的执行顺序和优先级

### 宏任务
宏任务是指在事件循环中每次迭代处理的任务。每当事件循环开始时，会从宏任务队列中取出一个任务并执行。宏任务的来源包括： 
 
-  setTimeout  
-  setInterval  
- I/O 操作（如文件读取、网络请求等） 
- UI 渲染 
 
宏任务的执行是一次性的，也就是说，只有在当前宏任务执行完毕后，才会去执行下一个宏任务。 

### 微任务
微任务是指在当前宏任务执行完成后、下一个宏任务开始之前需要执行的任务。微任务的优先级高于宏任务，微任务的来源包括： 
 
-  Promise  的  .then()  和  .catch()  回调 
-  MutationObserver  
 
微任务会在当前宏任务执行完毕后立即执行，且会在事件循环中优先处理微任务队列中的所有任务，直到微任务队列为空。然后，事件循环才会继续处理下一个宏任务。

### 执行顺序 
事件循环的执行顺序如下： 
 
1. 执行一个宏任务。 
2. 执行所有微任务，直到微任务队列为空。 
3. 渲染更新（如果有）。 
4. 继续下一个宏任务。


# 定时器
## setInterval需要注意的点
- 清除定时器，否则内存泄漏
- 定时器的精度，setInterval  的执行间隔并**不是绝对精确的**，尤其是在浏览器负载较重时，可能会出现延迟。由于 JavaScript 是单线程的，长时间运行的代码会阻塞定时器的执行。
- 计时器的上下文，this指向
- 可能多重复调用，条件判断或异步操作会导致意外的多重调用，确保逻辑清晰
- 关闭定时器的条件

## 定时器为什么是不精确的
- 单线程模型，这意味着它在任何给定的时间只能执行一个任务。当一个长时间运行的任务（如复杂的计算或 DOM 操作）正在执行时，定时器的回调函数可能会被延迟执行，导致定时器的实际触发时间比预期的时间要晚。 
- 定时器最小精度，在大多数浏览器中， setTimeout  和  setInterval  的最小时间间隔是 4 毫秒（在某些情况下可能更长），这意味着即使你设置了 1 毫秒的间隔，实际的回调函数可能会在更长的时间后执行。这个限制是为了优化性能和减少资源消耗。 
- 任务积压，如果定时器的回调函数执行时间超过了设定的间隔时间，可能会导致多个回调函数积压在队列中。虽然  setInterval  会按设定的间隔重复调用，但如果每次调用的执行时间较长，可能会导致间隔时间被打破
- 浏览器优化，和实现差异等

## setTimeout(1)和setTimeout(2)之间的区别
- ** setTimeout(1) **：表示延迟 1 毫秒后执行指定的函数。 
- ** setTimeout(2) **：表示延迟 2 毫秒后执行指定的函数。
虽然  setTimeout(1)  和  setTimeout(2)  在理论上有 1 毫秒的差别，但在实际执行中，由于 JavaScript 的定时器机制和浏览器的处理方式，这种差别可能不会那么明显。

# 闭包
## 介绍闭包，使用场景
- 闭包（Closure）是编程中的一个重要概念，尤其在函数式编程和JavaScript等语言中广泛使用。闭包允许一个函数访问并操作函数外部的变量，即使该函数在其外部作用域之外执行。闭包由两部分组成：函数本身以及创建该函数时的词法环境（即该函数被创建时作用域中的变量）。
### 闭包的特点
1. **封装私有变量**：闭包可以封装私有变量，这些变量只能通过闭包内部的函数访问，从而隐藏了实现细节。
2. **记忆性**：闭包可以记住并访问其词法作用域，即使函数在其词法作用域之外执行。
3. **模块化**：闭包可以用来创建模块，每个模块都有自己的私有变量和函数，这些私有变量和函数可以通过模块提供的公共接口进行访问。
### 使用场景
1. **数据封装和隐私**：
   闭包可以用来封装数据，使得这些数据只能通过特定的接口进行访问和修改，从而保护数据的隐私性和安全性。

2. **创建模块**：
   在JavaScript中，闭包常用于创建模块，每个模块都包含自己的私有变量和函数，以及对外暴露的公共接口。这有助于减少全局变量的使用，避免命名冲突，并提高代码的可维护性。

3. **回调函数和异步编程**：
   在JavaScript等支持回调函数的语言中，闭包常用于处理异步操作。由于闭包可以记住其词法作用域，因此可以在回调函数中使用外部作用域中的变量。

4. **函数工厂**：
   闭包可以用来创建函数工厂，即一个函数返回另一个函数。这些返回的函数可以访问并操作创建它们的函数中的变量。

5. **模拟私有方法和变量**：
   在JavaScript等不支持传统类私有成员的语言中，闭包可以用来模拟私有方法和变量。通过将私有变量和函数封装在闭包中，并通过闭包返回的函数来访问这些私有成员，可以实现类似私有成员的效果。

6. **实现装饰器模式**：
   装饰器模式是一种结构型设计模式，用于动态地给一个对象添加一些额外的职责。在JavaScript中，可以利用闭包来实现装饰器模式，通过闭包来封装原始对象，并在其基础上添加新的功能。
## 使⽤闭包特权函数的使用场景
- 数据封装和隐私保护
- 模块模式
- 单例模式
- 工厂模式
- 延迟初始化和懒加载

# 内存与垃圾回收相关
## 添加原生事件不移除为什么会内存泄露
- 引用保持：处理事件时可能会创建闭包；
- DOM节点引用：可能存在节点的引用，节点被移除后事件监听仍然存在，JS引擎无法回收
- 全局状态的引用：事件监听器引用了全局的状态，无法释放
- 循环引用：


## 还有哪些地⽅会内存泄露
- 事件监听
- 脱离的DOM：被移除的DOM还在被引用
- 闭包
- 定时器
- 循环引用
- 长周期对象：如单例模式
- web worker没有被正确终止

## JS⾥垃圾回收机制是什么，常用的是哪种，怎么处理的
‌JavaScript中的垃圾回收机制是为了防止内存泄漏，即当某块内存不再需要时，垃圾回收机制会找到这些内存并释放它们
- 引用计数
- 标记清楚（常用）

# 请求相关
## 前后端通信使⽤什么方案
## RESTful常⽤用的Method
- GET‌：用于请求服务器发送资源，通常用于获取信息。
- ‌POST‌：用于创建新的资源。
- ‌PUT‌：用于更新资源，客户端需要提供完整的资源数据。
- ‌PATCH‌：用于对资源进行部分修改，客户端只需提供需要修改的数据。
- ‌DELETE‌：用于删除指定的资源。
‌
## formData和原⽣生的ajax有什么区别
### 数据传输机制

- FormData: FormData 对象用以将数据编译成键值对，以便用 XMLHttpRequest 来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据 (keyed data)，而独立于表单使用。如果发送二进制数据或者文件，FormData 是首选。
- 原生 ajax: 原生的 ajax 是通过 XMLHttpRequest 对象直接发送字符串格式的数据，需要手动设置请求头，如 "Content-Type: application/x-www-form-urlencoded"。如果发送的是 JSON 数据，还需要将其转换为字符串。

### 安全性和性能
- FormData: FormData 可以方便地处理文件上传，并且可以异步地读取文件内容，这样可以提高大文件上传的性能。同时，由于 FormData 会为每个键值对或文件对创建一个单独的请求头，因此可以避免一些安全问题。
- 原生 ajax: 原生 ajax 在处理文件上传时需要读取整个文件内容后再发送，这可能会阻塞主线程，导致性能下降。同时，如果不小心处理请求头，可能会导致一些安全问题。

### 兼容性和易用性
- FormData: FormData 是 HTML5 的新特性，不支持 IE9 以下的浏览器。但是，由于其 API 设计得较为简单直观，因此在支持的浏览器上使用起来较为方便。
- 原生 ajax: 原生 ajax 的兼容性较好，几乎所有的浏览器都支持。但是由于需要手动处理请求头和数据转换，因此使用起来可能稍显复杂

## 介绍下表单提交，和formData有什么关系
## get和post有什什么区别
## 介绍下浏览器跨域
跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。
同源策略限制了一下行为：

Cookie、LocalStorage 和 IndexDB 无法读取
DOM 和 JS 对象无法获取
Ajax请求发送不出去
## 如何解决跨域的问题
- jsonp
- document.domain+iframe
- window.name+iframe
- postMessage
- 跨域资源共享 CORS
- node代理
- ng代理
## jsonp方案需要服务端怎么配合
前端
- 动态创建script
- 设置带参的src?=key&cb=callback及其他属性
- 将script标签插入dom中

后端
- 解析参数(回调函数名)
- 构造响应数据
- 发送响应，将构造好的数据以JavaScript函数调用的形式发送给客户端
## jsonp为什么不支持post方法
基于script标签的
## 表单可以跨域吗
可以跨域，但是不能返回请求数据
浏览器策略的本质是未经允许，不能读取另一个域名的内容，但是可以向另一个域名发送请求
## 跨域怎么解决，有没有使⽤过Apache等⽅案
## Ajax发⽣跨域要设置什么（前端）
## CORS如何设置
## 加上CORS之后从发起到请求正式成功的过程
- 简单请求的流程：浏览器直接发送CORS跨域请求，并在header信息中增加一个Origin字段，表明这是一个跨域的请求。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，浏览器收到这个回应发现这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道错了，从而会抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意这种错误无法通过状态码识别，此时HTTP回应的状态码可能是200
- 非简单请求的过程：非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。


## 常⻅Http请求头
## Http报⽂的请求会有⼏个部分
- 请求行
- 请求头
- 空行
- 请求数据

## ⽂件上传如何做断点续传
## 通过什么做到并发请求

## 前端和后端怎么联调

# 缓存相关
## cookie放哪里，cookie能做的事情和存在的价值
cookie存在本地，
## cookie和token都存放在header⾥⾯，为什么只劫持前者
- cookie:登录后服务端生成的sessionid，并在http请求里返回到客户端，同时服务端保存sessionid，以后客户端的每次http请求都带上cookie（sessionid）,服务端会获取cookie（sessionid）然后验证用户的身份。所以拿到cookie就拿到了sessionid，就可验证通过。同时浏览器会自动携带cookie;
- token：同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token 进行身份的校验。浏览器不会自动携带token。

## cookie和session有哪些⽅⾯的区别
存储位置‌：
- Cookie存储在用户的计算机上，由浏览器保存‌。
- Session存储在服务器上，服务器通过生成一个唯一的会话ID并存入Cookie中，每次用户请求时服务器通过这个ID识别用户‌

安全性‌：
- Cookie存储在客户端，容易被篡改或窃取，因此安全性较低‌
- Session存储在服务器端，相对更安全，不容易被篡改‌。

数据大小‌：
- Cookie存储的数据量较小，通常不超过4KB‌。
- Session没有数据大小的限制‌。

生命周期‌：
- Cookie有一定的生命周期，超过设定时间后会被删除‌。
- Session的生命周期与浏览器会话相同，用户关闭浏览器后Session结束‌。

适用场景‌：
- Cookie适用于存储少量的、非敏感的数据，如用户偏好设置、登录状态等‌。
- Session适合存储需要跨页面访问的敏感信息

## 介绍localstorage的API

## 如何设计⼀一个localStorage，保证数据的实效性
set:定义结构`{value:'',expires:'过期的时间'}`
get:判断expires时间是否早于当前时间，是则过期，否返回value


# 异步相关
## JS异步解决⽅案的发展历程以及优缺点
回调函数
- 优点：易上手、简单
- 缺点：回调地狱，错误处理难，代码复用困难

Promise
- 优点：链式调用、错误捕获方便，代码易复用
- 缺点：无法取消，一旦创建promise无法取消，只能表示一次性结果

Generator
- 优点：可以暂停恢复执行，可以使用同步方式
- 缺点：需要手动控制迭代，无法自动捕错

Async/Await
- 优点：易读，错误处理方便
- 缺点：无法取消已经开始的异步操作

## 介绍异步方案
## 介绍Promise
## Promise有⼏个状态
## promise如何实现then处理
## 介绍下Promise的⽤途和性质
## Promise和Callback有什什么区别
- callback函数处理异步：代码逻辑复杂，可读性差----回调地狱；不可return；
- promise处理异步：对比callback，易读，可以return，不需要层层传递callback；处理多个异步等待合并

## promise⾥面和then⾥面执⾏有什么区别
## 介绍Promise，异常捕获
## 对async、await的理理解，内部原理理
async/await可以使异步代码在形式上更接近于同步代码。这就是它最大的价值。

async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。
## 介绍下Promise，内部实现
## 如何设计Promise.all()
## 使⽤用Async会注意哪些东⻄西
- await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。
- 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。
- await命令只能用在async函数之中，如果用在普通函数，就会报错。
- async 函数可以保留运行堆栈。

## Async⾥面有多个await请求，可以怎么优化（请求是否有依赖）
## Promise和Async处理理失败的时候有什什么区别
promise失败trycatch捕获不到使用.catch(),Async可以是用trycatch
## promise的精髓，以及优缺点

# 浏览器事件

## 浏览器器事件流向
 
## 事件委托

## 介绍事件代理理以及优缺点
- 优点：1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
- 缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。
## <a>标签默认事件禁掉之后做了什么才实现了跳转


## 设计模式相关
## 介绍观察者模式
## 介绍中介者模式
## 观察者和订阅-发布的区别，各⾃用在哪⾥

# 安全相关
## 项⽬目中如何处理理安全问题
## 对安全有什什么了了解
## csrf跨站攻击怎么解决
## 介绍下数字签名的原理
## xsrf跨域攻击的安全性问题怎么防范

# canvas相关
## 使⽤用canvas绘图时如何组织成通⽤用组件


## 介绍MVP怎么组织
1. ⼩小程序⾥里里⾯面开⻚页⾯面最多多少
3. Emit事件怎么发，需要引⼊入什什么

6. 在哪个⽣生命周期⾥里里写
7. 其中有⼏几个name不不存在，通过异步接⼝口获取，如何做
8. 渲染的时候key给什什么值，可以使⽤用index吗，⽤用id好还是index好





18. 上述数组随机取数，每次返回的值都不不⼀一样

21. 如何判断是button

23. 循环绑定时的index是多少，为什么，怎么解决
24. ⻚页⾯面上有⼀一个input，还有⼀一个p标签，改变input后p标签就跟着变化，
如何处理理
25. 监听input的哪个事件，在什什么时候触发


1. Linux 754 介绍

5. 搜索请求如何处理理（防抖）
6. 搜索请求中⽂文如何请求
## 介绍service worker
## 对PWA有什么了解


24. 前端怎么控制管理路由
25. 使⽤路由时出现问题如何解决
3. 如何处理理异常捕获
4. 项⽬目如何管理理模块


