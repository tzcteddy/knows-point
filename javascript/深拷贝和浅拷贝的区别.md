## 深拷贝和浅拷贝的区别

+ 基本数据类型：赋值不会互相影响
+ 引用数据类型：两个变量具有相同的引用，指向同一个对象，相互之间有影响

### 浅拷贝

创建一个对象，将原始对象数据精确的拷贝到新对象种，规则：如果是基本数据类型，就拷贝值；如果是引用数据类型拷贝的是内存地址；

#### Object.assign()
```js
var obj={user:{name:'duidian',age:12}}
var obj2=Object.assign({},obj)
obj2.user.age=13
console.log(obj.user.age) //13
```

#### 展开语法
```js
var obj3={...obj}
obj3.user.age=14
console.log(obj.user.age) //14
```

#### Array.prototype.slice()

```js
var ary=[0,'1',[2,3]]
var ary2=ary.slice(1)
ary2 //['1',[2,3]]
ary2[1][0]=4
ary[2][0] //4
```


### 深拷贝

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

#### JSON.parse(JSON.stringify(object))

这个方法存在的问题：

但是该方法有以下几个问题。

1. 会忽略 `undefined`

2. 会忽略 `symbol`

3. 不能序列化函数

4. 不能解决循环引用的对象

5. 不能正确处理`new Date()`

6. 不能处理正则

**undefined、symbol 和函数这三种情况，会直接忽略。**

```js
var obj={
      name:undefined,
      getName:function(){console.log(this.name)},
      type: Symbol('duidian'),
      age:12
    }

var obj2=JSON.parse(JSON.stringify(obj))
obj2 //{age:12}
```

**循环引用会报错**

```js
let obj = {
    a: 1,
    b: {
      c: 2,
   		d: 3
    }
}
obj.a = obj.b;
obj.b.c = obj.a;
let b = JSON.parse(JSON.stringify(obj));

// Uncaught TypeError: Converting circular structure to JSON
```
**Date转换错误**
```js
var time=new Date()
time
//Thu Apr 15 2021 11:20:49 GMT+0800 (中国标准时间)
JSON.parse(JSON.stringify(time))
//"2021-04-15T03:20:49.932Z"
```
可以转为字符串或时间戳处理

**正则会发生如下事故**

```js
let obj = {
    name: "duidian",
    a: /'123'/
}
console.log(obj);
// {name: "duidian", a: /'123'/}
let b = JSON.parse(JSON.stringify(obj));
console.log(b);
// {name: "duidian", a: {}}
```
