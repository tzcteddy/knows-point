## 高阶编程 

### 惰性函数

### 柯理化函数

```js
var add = (a, b, c) => a + b + c
add(1, 2, 3) // 6
```
假如有这样一个 `curry` 函数, 用其包装 `add` 函数后返回一个新的函数 `curryAdd`, 我们可以将参数 `a`、`b` 进行分开传递进行调用。
```js
var curryAdd = curry(add)
// 以下输出结果都相同
curryAdd(1, 2, 3) // 6
curryAdd(1, 2)(3) // 6
curryAdd(1)(2)(3) // 6
curryAdd(1)(2, 3) // 6
```

核心思路: 若传进去的参数个数未达到 curryAdd 的个数，则将参数缓存在闭包变量 lists 中:

```js
function curry(fn, ...args) {
  const length = fn.length
  let lists = args || []
  let listLen
  return function (..._args) {
    lists = [...lists, ..._args]
    listLen = lists.length
    if (listLen < length) {
      const that = lists
      lists = []
      return curry(fn, ...that)
    } else if (listLen === length) {
      const that = lists
      lists = []
      return fn.apply(this, that)
    }
  }
}
```
### compose组合函数
现在有 `toUpperCase`、`reverse`、`head` 三个函数, 分别如下:
```js
var toUpperCase = (str) => str.toUpperCase()
var reverse = (arr) => arr.reverse()
var head = (arr) => arr[0]
```
接着使用它们实现将数组末位元素大写化输出, 可以这样做:
```js
var reverseHeadUpperCase = (arr) => toUpperCase(head(reverse(arr)))
reverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH
```

此时在构建 `reverseHeadUpperCase` 函数的时候, 必须手动声明传入参数 `arr`, 是否能提供一个 `compose` 函数让使用者更加友好的使用呢? 类似如下形式:

```js
var reverseHeadUpperCase = compose(toUpperCase, head, reverse)
reverseHeadUpperCase(['apple', 'banana', 'peach']) // PEACH
```
此外 `compose` 函数符合结合律, 我们可以这样子使用:

```js
compose(compose(toUpperCase, head), reverse)
compose(toUpperCase, compose(head, reverse))
```
以上两种写法与 `compose(toUpperCase, head, reverse)` 的效果完全相同, 都是依次从右到左执行传参中的函数。

此外 `compose` 和 `map` 一起使用时也有相关的结合律, 以下两种写法效果相等
```js
compose(map(f), map(g))
map(compose(f, g))
```

实现一个：

```js
var compose = (...args) => (initValue) => args.reduceRight((a, c) => c(a), initValue)
```
参考：
[https://www.yuque.com/fe9/basic/pq4mzx](https://www.yuque.com/fe9/basic/pq4mzx)
[http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)