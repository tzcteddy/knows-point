## 图片压缩和视频截取帧图片

我们可以利用 Canvas 对象提供的 toDataURL() 方法，该方法接收 type 和 encoderOptions 两个可选参数。
+ type 表示图片格式，默认为 image/png。
+ encoderOptions 用于表示图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92，其他参数会被忽略。

### 对图片进行等比例压缩

**获取base64**
```js
/**
* @param file file对象或base64格式
**/
getBase64(file){
    if(/^data:.*;base64,/.test(file)){
        return new Promise((resolve)=>{
            resolve(file)
        })
    }
    let reader = new FileReader()
    reader.readAsDataURL(file)
    return  new Promise((resolve,reject)=>{
        reader.onload=()=>{
            resolve(reader.result)
        }
    })
}
```
**定义要压缩图片的参数**
```js
/**
* @param base64
* @param w 宽度参数  0-1
* @param quality 质量参数 0-1
* @param type 类型
* **/
getRatio(base64,w,quality,type){
    let img=new Image();
    img.src=base64;
    type=type||base64.split(',')[0].match(/^data:(.*);base64$/)[1];
    return new Promise((resolve,reject)=>{
        img.onload=()=>{
            let width=img.width;
            let height=img.height;
            let scale = width / height;
            let newWidth=width*w
            let newInfo={
                imgNode:img,
                w:newWidth,
                h:newWidth/scale,
                quality:quality,
                type:type
            }
            resolve(newInfo)
        }
    })
}
```
**获取压缩后图片的base64**
```js
canvasDateUrl(imgInfo){
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var anw = document.createAttribute("width");
    anw.nodeValue = imgInfo.w;
    var anh = document.createAttribute("height");
    anh.nodeValue = imgInfo.h;
    canvas.setAttributeNode(anw);
    canvas.setAttributeNode(anh);
    ctx.drawImage(imgInfo.imgNode, 0, 0, imgInfo.w, imgInfo.h);
    var base64 = canvas.toDataURL(imgInfo.type, imgInfo.quality);
    return base64
}
```

### 截取视频帧图片(按时间)
```js
 /**
 * @param base64 
 * @param time 获取帧 秒
 * **/
captureImage(base64,time=1){
    let video=document.createElement('video');
    video.src=base64;
    video.currentTime=time;
    let canplay=true;
    return new Promise((resolve,reject)=>{
        video.oncanplay=()=>{
            var canvas = document.createElement("canvas"); // 创建一个画布
            canvas.width = video.videoWidth * 1;
            canvas.height = video.videoHeight * 1;
            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
            let captureImage=canvas.toDataURL("image/png");
            resolve(captureImage)
        }
    })
}
```

更为详细一份图片压缩

```js
const MAX_WIDTH = 800; // 图片最大宽度

function compress(base64, quality, mimeType) {
  let canvas = document.createElement("canvas");
  let img = document.createElement("img");
  img.crossOrigin = "anonymous";
  return new Promise((resolve, reject) => {
    img.src = base64;
    img.onload = () => {
      let targetWidth, targetHeight;
      if (img.width > MAX_WIDTH) {
        targetWidth = MAX_WIDTH;
        targetHeight = (img.height * MAX_WIDTH) / img.width;
      } else {
        targetWidth = img.width;
        targetHeight = img.height;
      }
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      let ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, targetWidth, targetHeight); // 清除画布
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      let imageData = canvas.toDataURL(mimeType, quality / 100);
      resolve(imageData);
    };
  });
}
```
对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：
```js
function dataUrlToBlob(base64, mimeType) {
  let bytes = window.atob(base64.split(",")[1]);
  let ab = new ArrayBuffer(bytes.length);
  let ia = new Uint8Array(ab);
  for (let i = 0; i < bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeType });
}
```
在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：

```js
function uploadFile(url, blob) {
  let formData = new FormData();
  let request = new XMLHttpRequest();
  formData.append("image", blob);
  request.open("POST", url, true);
  request.send(formData);
}
```

其实 Canvas 对象除了提供 `toDataURL()` 方法之外，它还提供了一个 `toBlob()` 方法，该方法的语法如下：

    canvas.toBlob(callback, mimeType, qualityArgument)

和 `toDataURL()` 方法相比，`toBlob()` 方法是异步的，因此多了个 `callback` 参数，这个 `callback` 回调方法默认的第一个参数就是转换好的 blob文件信息。







